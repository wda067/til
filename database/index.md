# 인덱스

- 데이터베이스에서 인덱스는 다음 세 가지 상황에 사용된다.
  - 동등 비교(`=`)
  - 범위 검색(`BETWEEN`, `>`, `LIKE` 등)
  - `ORDER BY`를 통한 정렬 작업

## 동등 비교

- `type: ref`는 동등 비교 조건이나 `JOIN`에서 인덱스를 사용했다는 의미이다.
- 인덱스를 통해 조건에 맞는 데이터를 매우 효율적으로 참조해서 가져왔다는 뜻이다.

## BETWEEN 범위 검색

- `type: range`는 인덱스를 사용해 특정 범위의 데이터를 스캔했음을 의미한다.
- 처음 한 번만 찾고, 이후에는 별도의 탐색 과정 없이 연속해서 결과를 구할 수 있다.

## LIKE 범위 검색

- `LIKE` 절에서 인덱스를 사용하려면 `%`가 검색어 뒤쪽에 위치해야 한다.
- `%`가 앞에 있으면 시작점이 불분명해져 정렬된 인덱스를 활용할 수 없기 때문이다. 
- 여기서도 인덱스의 범위 검색을 사용할 수 있는데 글자가 정렬되어 있기 때문이다.

### 전체 문자 검색

- `LIKE '%검색어%'` 방식은 데이터가 많아질수록 성능이 심각하게 저하되어 실제 서비스에서는 사용하기 어렵다.
- 이런 `내용 검색` 또는 `포함 검색` 문제를 해결하기 위해 데이터베이스는 **전문 검색**(**Full-Text Search**)이라는 특수한 기능을 제공한다.
- B-Tree 인덱스와는 달리 텍스트를 단어(토큰) 단위로 쪼개어 인덱싱하는 방식이다.
- 만약 쇼핑몰에서 상품명 검색 기능을 구현해야 한다면, `LIKE` 대신 `MATCH ... AGAINST` 구문을 사용하는 전문 검색 기능을 도입하는 것이 해결 방법이다.

## 정렬

- 데이터베이스에서 정렬 작업은 비용이 많이 드는 무거운 작업이다.
- `ORDER BY`가 인덱스를 잘 활용하면 별도의 정렬 과정없이 이미 정렬된 인덱스를 순서대로 읽기만 하면 되므로 매우 빠르게 동작한다.
- 이 과정에서 `filesort`라는 별도의 정렬 작업을 생략할 수 있다.

### 인덱스를 역방향으로 조회하는 경우

- 역방향으로 조회해도 단일 컬럼 인덱스에서는 `filesort`없이 효율적인 처리가 가능하다.
- 데이터베이스 옵티마이저는 인덱스를 거꾸로 읽는, 즉 **역방향 스캔**(**Backward Index Scan**)을 할 수 있기 때문이다.
- `Extra: Backward index scan`는 옵티마이저가 역순으로 스캔했음을 의미한다.

### 내림차순 인덱스

- 역방향 스캔도 이미 효율적이지만 인덱스를 처음부터 내림차순으로 정렬하여 저장할 수도 있다.
- `CREATE INDEX idx_items_price_desc ON items (price DESC);`
- 여러 컬럼을 기준으로 정렬 순서가 각각 다르다면, 복합 인덱스에서 각 컬럼별로 `ASC/DESC`를 지정해 원하는 정렬 방향에 최적화된 인덱스를 구성할 수 있다.

## 인덱스 선택

- 인덱스를 사용한다고 무조건 성능이 향상되는 것은 아니다.
- **인덱스를 사용하는 비용**: 인덱스 탐색 비용 + 인덱스에서 찾은 주소로 테이블에 접근하는 비용 (랜덤 I/O)
- **풀 테이블 스캔 비용**: 테이블 전체를 순차적으로 읽는 비용 (순차 I/O)
- 일반적으로 **전체 데이터의 약 20~25% 이상을 조회해야 하는 쿼리**는 인덱스를 사용하는 것보다 **풀 테이블 스캔**이 더 효율적이라고 알려져있다.

## 커버링 인덱스

- **쿼리에 필요한 모든 컬럼을 포함하고 있는 인덱스**를 말한다.
- 옵티마이저는 특정 인덱스가 `SELECT`, `WHERE`, `ORDER BY`, `GROUP BY`절에 사용되는 모든 컬럼을 가지고 있다면, **원본 테이블에 전혀 접근하지 않고 오직 인덱스만을 읽어서 쿼리를 처리**한다.
- 이는 랜덤 I/O 작업을 제거하고, 순차 I/O에 가까운 인덱스 스캔만으로 끝낼 수 있음을 의미한다.
- `Extra: Using index condition`는 **`WHERE`절을 필터링하는 데 인덱스를 사용했지만, 추가 작업이 필요**하다는 의미이다.
- `Extra: Using index`는 모든 데이터를 **오직 인덱스에서만 읽어서 처리**했음을 의미한다.

### 장점

- **압도적인 SELECT 성능 향상**: 테이블 접근을 위한 랜덤 I/O를 제거하여 조회 성능을 극적으로 개선한다.
- **COUNT 쿼리 최적화**: `SELECT COUNT(*)`와 같은 쿼리에서 테이블 전체가 아닌, 크기가 훨씬 작은 인덱스만 스캔하여 결과를 빠르게 반환할 수 있다.

### 단점

- **저장 공간 증가**: 인덱스는 원본 데이터와 별도의 저장 공간을 차지한다. 인덱스에 포함되는 컬럼이 많아질수록 인덱스의 크기도 커진다.
- **쓰기 성능 저하**: 인덱스가 많고 복잡할수록 쓰기 작업에 대한 부하가 커진다.

### 언제 사용해야 할까?

- **조회(읽기)가 매우 빈번하고, 쓰기 작업은 상대적으로 적은 테이블**에 적용하는 것이 가장 효과적이다.
- `SELECT`절에서 조회하는 컬럼의 개수가 적을 때 유리하다.
