# 데이터베이스 설계

## 개념적 설계

- **목표**: 비즈니스의 요구 사항을 이해하고, 핵심 데이터가 무엇인지 정의하는 것. 개발자뿐만 아니라 기획자, 현업 담당자 등 비전문가와 소통하는 것이 주된 목적이다.
- **사용 용어**: `엔티티(Entity)` , `속성(Attribute)` , `관계(Relationship)`
- 개념 모델의 용어는 '현실 세계를 추상적으로 표현'하고 '원활하게 소통'하기 위해 존재한다.
- **산출물**: `ERD (Entity-Relationship Diagram)`

### 엔티티 찾기

- 명사를 찾는다.
    1. 눈에 보이는 명사(고객, 상품 등)를 찾아 엔티티 후보로 삼는다.
    2. 중요한 동사(주문하다, 예약하다 등)을 찾는다.
    3. 해당 동사가 "관리해야 할 기록이나 증빙을 남기는가?" 판단한다.
    4. 그렇다면, 그 동사의 명사형(주문, 예약 등)을 새로운 엔티티로 만든다.

### ERD

- `O|`: 0개 또는 1개 (선택적 1)
- `||`: 반드시 1개 (필수적 1)
- `O<`: 0개 이상 (선택적 N)
- `|<`: 1개 이상 (필수적 N)

#### 회원:주문

- 한 명의 회원은 주문을 0개 이상 가질 수 있다. (선택적 N)
- 하나의 주문은 반드시 한 명의 회원을 가져야 한다. (필수적 1)
- 최종 관계: 회원 (`||`)---(`O<`) 주문

## 논리적 설계

- **목표**: 개념적 설계에서 만든 밑그림을, RDBMS의 원리에 맞게 구체적인 구조로 다듬는 단계이며 특정 RDBMS에 종속되지 않는, 순수한 논리적인 데이터 구조를 만든다.
- **사용 용어**: `릴레이션(Relation)`, `속성`, `튜플(Tuple)`, `기본 키(PK)`, `외래 키(FK)`
- 논리 모델의 용어는 '관계형 데이터베이스의 규칙에 맞게 데이터를 구조화'하기 위한 표준 언어이다.
- **산출물**: 정규화된 테이블 스키마

#### 기본 키 조건

- `NOT NULL`
- `UNIQUE`
- 불변성
  - 이론적으로 기본 키의 값을 변경할 수 있으나, 데이터 무결성에 문제가 생기므로 **실무에서는 기본 키의 값을 변경하면 안된다**.

#### 자연 키

- 이메일, 주민번호와 같은 의미를 가진 데이터
- 장점:
  - 직관성
  - 중복 방지
- 단점:
  - 변경 가능

#### 대리 키

- 비즈니스 로직과 무관한, 데이터를 식별하기 위한 용도로만 존재하는 임의의 값
- 순차적으로 증가하는 정수, UUID

#### 자연 키의 올바른 사용법: UNIQUE 제약조건

- **PK는 대리 키로 설정하고**, 비즈니스적으로 고유해야 하는 자연 키는 `UNIQUE` 제약조건을 설정한다.
- `UNIQUE` 제약조건을 설정하면, 자동으로 인덱스가 생성되므로 조회 성능도 보장된다.

#### 자연 키 사용의 단점

- **외래 키 크기**:
  - **공간 낭비**: 
    - 일반적인 대리 키로 사용하는 `BIGINT`(8바이트)에 비해 훨씬 많은 디스크 공간을 차지한다.
  - **성능 저하**: 
    - 테이블과 인덱스의 크기가 커지면 메모리에 한 번에 올릴 수 있는 데이터의 양이 줄어든다.
    - 조인 연산 시 비교해야 할 데이터의 크기가 커져 메모리, CPU 사용량도 늘어난다.
    - 즉, 전반적인 데이터베이스 성능 저하로 이어진다.
- **인덱스 단편화와 쓰기 성능 저하**:
  - `email`과 같은 자연 키는 일반적으로 알파벳순이나 가입 순서와 무관하게 생성된다.
  - 데이터베이스는 이 값들을 정렬된 상태로 인덱스에 저장해야 하므로, 이 과정에서 인덱스 페이지를 나누는 **페이지 분할**이 빈번하게 발생한다.
  - 결과적으로 인덱스 내부에 빈 공간이 많이 생기는 단편화가 심해지고, 이는 쓰기 성능 저하를 유발한다.

#### 대리키 사용의 장점

- **뛰어난 쓰기 성능**
  - `AUTO_INCREMENT`나 `SEQUENCE`를 사용하는 대리 키는 인덱스 구조의 가장 마지막에 차례대로 추가하면 된다.
  - 이는 페이지 분할을 거의 일으키지 않으므로 인덱스 단편화 문제가 발생하지 않는다.
- **외래 키 크키 최소화**
  - `BIGINT` 타입의 대리 키는 8바이트 고정 크기를 가진다.
  - 이는 `VARCHAR(50)`같은 가변 길이 문자열보다 훨씬 작고 효율적이다.

현대적인 데이터베이스 설계는 대리 키-`PK`, 자연 키-`UNIQUE` 방식이 사실상 표준이다

### 식별 관계 vs 비식별 관계

#### 식별 관계

- 부모 테이블의 기본 키를 자식 테이블의 **기본 키의 일부**로 사용
- 약한 엔티티
- ERD에서 실선으로 표시

#### 비식별 관계

- 부모 테이블의 기본 키를 단순히 **일반 컬럼**으로 사용
- 강한 엔티티
- ERD에서 `---`으로 표시
- ORM 친화적

현대 애플리케이션 개발에서는 '기본적으로 모든 관계는 **비식별 관계**로 설계하고, PK는 비즈니스와 무관한 **대리 키**를 사용한다' 는 원칙을 따르는 것이 현명한 선택이다.

## 물리적 설계

- **목표**: 논리적 설계에서 만든 테이블 스키마를, 실제 사용할 특정 RDBMS의 특성에 맞게 최적화하여 구현하는 마지막 단계다.
- **사용 용어**: `테이블(Table)`, `컬럼(Column)`, `행(Row)`, `데이터 타입(VARCHAR, INT)`, `인덱스(Index)`
- 물리 모델의 용어는 '특정 데이터베이스에 최적화된 방식으로 데이터를 구현'하기 위한 구체적인 언어이다.
- **산출물**: 물리적인 테이블 정의서, SQL 스크립트 (`CREATE TABLE ...`)

#### 테이블 명: 단수 vs 복수

- 정답은 없으며 한국에서는 주로 단수형을 사용한다.

### 데이터 타입

#### 문자열 타입

- `VARCHAR(M`): 가변 길이 문자열. 
  - `M`은 저장할 수 있는 **최대 길이**를 의미한다.
  - 공간 효율이 좋다.
- `CHAR(M)`: 고정 길이 문자열. 
  - `M`은 고정된 길이를 의미한다.
  - 공간 낭비가 심하다.
- `TEXT`: 매우 긴 텍스트를 저장할 때 사용한다.
  - `TEXT`는 약 6만 5바이트, `MEDIUMTEXT`는 약 1600만 바이트, `LONGTEXT`는 약 42억 바이트.

대부분의 경우 `VARCHAR`가 가장 합리적인 선택이다. `VARCHAR`의 길이는 너무 길게 잡으면 메모리 사용량이 늘어날 수 있고, 너무 짧게 잡으면 데이터가 잘리는 문제가 생긴다. 저장될 데이터의 평균적인 길이와 최대 길이를 고려하여 합리적으로 설정해야 한다. 예를 들어, 사용자 이름은 50자, 이메일 주소는 100자 정도로 잡는 것이 일반적이다.

##### VARCHAR 갈아는 왜 메모리 사용량에 영향을 줄까?

- MySQL이 쿼리를 처리하기 위해 메모리에 임시 공간을 할당할 때 `VARCHAR`에 설정된 최대 길이를 기준으로 삼는 경우가 많다.
- 수백만 건의 데이터를 정렬한다고 할 때, `VARCHAR(50)`일 때와 `VARCHAR(4000)`일 때, 정렬 작업을 위해 필요한 총 메모리의 양은 큰 차이가 난다. 
- 만약 할당해야 할 메모리가 너무 커서 서버의 물리적인 메모리(RAM) 용량을 초과하면, MySQL은 디스크를 임시 공간으로 사용하기 시작한다. 
- 디스크 I/O는 메모리 I/O보다 수천 배에서 수만 배 느리기 때문에, 이는 곧바로 쿼리 성능의 급격한 저하로 이어진다.

#### 숫자 타입

##### 정수 타입

![alt text](https://github-production-user-asset-6210df.s3.amazonaws.com/75603567/520402911-4d1b92d3-779a-4a1d-adeb-d6bd15666e5e.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251129T161957Z&X-Amz-Expires=300&X-Amz-Signature=141542dc59a7caa546bcbc48934c6b9341812c98e39e78cd8325582daab8606a&X-Amz-SignedHeaders=host)

- `TINYINT`는 상태 값이나 한정된 범위의 숫자에 사용하면 공간을 매우 효율적으로 쓸 수 있다.
- 일반적인 게시물 ID, 회원 ID 등은 `INT`로 충분한 경우가 많다. 
- 하지만 양수만 저장하는 경우 `UNSIGNED` 옵션을 사용하면 저장 범위를 2배로 늘릴 수 있다. 
- 예를 들어 `INT UNSIGNED`는 0부터 약 42억까지 저장할 수 있어, 음수가 필요 없는 ID 값에 사용하기 좋다.
- 서비스가 엄청나게 커질 것을 대비해 무조건 `BIGINT`를 사용하는 경우가 있는데, 이는 신중해야 한다.
- 트래픽이 많지 않은 관리자 페이지의 ID 등은 `INT`로도 충분하다. 

##### 소수 타입

- `DECIMAL(M, D)`: 고정 소수점 타입
  - 금융 계산처럼 정확한 소수점 계산이 필요할 때 반드시 사용해야 한다.
  - `M`은 총 자릿수, `D`는 소수점 이하 자릿수를 의미한다.
  - `DECIMAL(10, 2)`는 정수 부분 8자리, 소수 부분 2자리.
- `DOUBLE` or `FLOAT`: 부동 소수점 타입.
  - 근사치가 허용되는 빠른 계산에 사용된다.
  - 미세한 오차가 발생할 수 있어, 돈과 관련된 계산에는 절대 사용하면 안된다.

##### PK 타입: INT vs BIGINT

- `INT`는 `UNSIGNED` 옵션을 사용하면 42억까지 가능하지만, 현대 서비스에서는 주문·로그 등 데이터가 수십억 건을 넘어 `INT` 한계를 넘을 위험이 있다.
- `BIGINT`는 2배 저장 공간을 쓰지만, 실제로는 1억 건이나 되어서야 수백 MB 차이라 비용이 매우 작다.
- 인덱스 크기 차이로 `INT`가 이론상 조금 빠르지만, 실무에서 체감되는 성능 차이는 거의 없다.
- `INT`로 설계했다가 용량을 초과하면 `BIGINT`로의 마이그레이션은 서비스 전체에 재앙적 비용을 초래할 수 있다.
- 그래서 실무에서는 확장성·일관성·FK 관리 편의성 때문에 모든 테이블 PK를 `BIGINT`로 통일하는 방식을 선호한다.

#### 날짜와 시간 타입

- `DATE`: 날짜만 저장한다. 'YYYY-MM-DD' 형식.
- `DATETIME`: 날짜와 시간을 함께 저장한다. 'YYYY-MM-DD HH:MI:SS' 형식. 
- `TIME`: 시간만 저장한다. 'HH:MI:SS' 형식.
- 회원 가입일, 주문일, 게시물 작성일 등 대부분의 경우 `DATETIME`을 사용한다.
- 생년월일처럼 시간 정보가 필요 없는 경우에는 `DATE`를 사용한다.
- 특별한 이유가 없다면 `TIMESTAMP` 대신에 `DATETIME`을 사용하는 것이 더 직관적이고 안전하다.
- 실무에서는 대부분의 테이블에 `created_at`과 `updated_at` 컬럼을 추가한다. 이 데이터는 나중에 문제 추적이나 데이터 분석에 매우 유용하게 사용된다.

### 역정규화

#### 중복 컬럼 추가

- 가장 흔하게 사용되는 기법이다. 
- `JOIN`을 줄이기 위해 조회 시 자주 필요한 다른 테이블의 컬럼을 그대로 복사해서 가져오는 것이다.
- 이 방식의 치명적인 단점은 데이터 불일치 가능성이다.
- 주문 당시의 상품명, 가격 등은 '역사적 데이터'로 취급하여 변경하지 않는 것이 비즈니스 규칙상 타당할 수 있다. 
- 이런 경우에는 중복 컬럼 추가가 매우 효과적인 해결책이 된다.

#### 파생 컬럼 추가 (계산된 값의 저장)

- 조회 시점에 복잡한 계산(`SUM`, `COUNT` 등)이 필요하여 부하가 발생하는 경우, 그 계산 결과를 미리 컬럼에 저장해 두는 방식이다.
- 이 기법은 쓰기(Write) 작업의 부하를 증가시킨다. 

#### 테이블 통합 및 분할

- **테이블 통합**: 1:1 또는 1:N 관계에서 항상 함께 조회되는 테이블들을 하나의 테이블로 합쳐 JOIN 을 원천적으로 제거한다.
- **테이블 분할**: 하나의 테이블에 컬럼이 너무 많고, 일부 컬럼만 자주 사용될 때 테이블을 수직으로 분할(Vertical Partitioning)하여 디스크 I/O 성능을 높일 수 있다.

### 테이블 정의서

잘 작성된 테이블 정의서는 DDL만으로는 알 수 없는 풍부한 맥락을 제공하여, 개발자나 데이터 분석가가 데이터의 구조와 의미를 명확하게 이해할 수 있도록 돕는다.

![alt text](https://github-production-user-asset-6210df.s3.amazonaws.com/75603567/520402912-cf9a1a73-7c5b-4af4-8f88-779035a644a2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251129T161940Z&X-Amz-Expires=300&X-Amz-Signature=b99ee6122dd12c51d7a53bf64b47256ca5eeb62ebebe7d4416f3e92c4dc1a594&X-Amz-SignedHeaders=host)

![alt text](https://github-production-user-asset-6210df.s3.amazonaws.com/75603567/520402914-7d47398d-4442-4ee5-bc94-16eb81857d76.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251129T161926Z&X-Amz-Expires=300&X-Amz-Signature=28368cb43e3d869c67bb833ddab29b839a9a2dee118a8084c6bdebf170e7857c&X-Amz-SignedHeaders=host)
![alt text](https://github-production-user-asset-6210df.s3.amazonaws.com/75603567/520402913-ec8d1f85-1f5e-46cc-ab21-530911ad6107.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAVCODYLSA53PQK4ZA%2F20251129%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20251129T161845Z&X-Amz-Expires=300&X-Amz-Signature=b67350742c49febaa92277f1b99e32e9f5f28d405a95efae3eb173dc603fe8e6&X-Amz-SignedHeaders=host)